
PROGRAM = {STMT}

BODY = "{" {STMT} "}" STMT_DELIM
STMT = (ASSIGN | DEFINE | CALL | GUARD | MATCH) STMT_DELIM
STMT_DELIM = ";"

LOOP = "loop" IDENT "," IDENT "," IDENT "<-" (IDENT | CALL | LIST | MAP) BODY
LOOP = "loop" [ASSIGN] GUARD_COND [STMT] BODY

MATCH = "match" EXPR "{" STMT_DELIM {CASE} "}"
CASE = (EXPR | GUARD_COND) ":" (STMT | BODY)

GUARD = GUARD_COND (STMT | BODY)
GUARD_COND = "[" EXPR "]"

DEFINE = INF_VAR ":=" ROUTINE | FUNC
DEFINE = INF_VAR {"," INF_VAR} ":=" EXPR {"," EXPR}
DEFINE = "type" IDENT ":=" TYPE

ASSIGN = INF_VAR "<-" FUNC
ASSIGN = INF_VAR {"," INF_VAR} "<-" EXPR {"," EXPR}

FUNC = "E" "(" VAR_LIST "->" TYPE ")" EXPR
FUNC = "E" "(" VAR_LIST "->" EXP_VAR ")" BODY
ROUTINE = "F" "(" VAR_LIST ["->" VAR_LIST] ")" BODY
VAR_LIST = [EXP_VAR {"," EXP_VAR}]
INF_VAR = IDENT [TYPE]
EXP_VAR = IDENT TYPE

FUNC_SIG = "E" "(" SIG_PARAMS "->" TYPE ")"
ROUTINE_SIG = "F" "(" SIG_PARAMS ["->" SIG_PARAMS] ")"
SIG_PARAMS = [SIG_PARAM {"," SIG_PARAM}]
SIG_PARAM = [IDENT] TYPE

EXPR = EXPR INFIX_OPERATOR EXPR
EXPR = EXPR "?"
EXPR = ("!" | "-") EXPR
EXPR = "(" EXPR ")"
EXPR = BOOL | NUMBER | STRING | IDENT | CALL | LIST | MAP

MAP = "{" [EXPR ":" EXPR {"," EXPR ":" EXPR}] "}"
LIST = "[" [EXPR {"," EXPR}] "]"
CALL = ["@"] IDENT "(" {EXPR} ")"
IDENT = "_" | (LETTER {LETTER | DIGIT | "_"})

STRING = '"' *Any unicode char (needs refining)* '"'
NUMBER = DIGIT {DIGIT} ["." DIGIT {DIGIT}]
BOOL = "true" | "false"

TYPE = "B" | "N" | "S" | IDENT | ROUTINE_SIG | FUNC_SIG
INFIX_OPERATOR = "==" | "!=" | "<" | ">" | "<=" | ">=" | "+" | "-" | "*" | "/" | "%" | "||" | "&&"
LETTER = *Any unicode char from categories 'Lu' or 'Ll' (needs expanding)*
DIGIT = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"



*** Considering ***

// Overloaded func & e-func definitions (but not assignments) 
check := E(n N -> B) n > 0
check := E(b B -> B) b
check := E(s S -> B) @Len(s) <= 8

// Return statement using `<~` as the return symbol
fac := E(n N -> r N) {
	match n {
		0: <~ 0
		1: <~ 1
		[true]: <~ n + fac(n-1)
	}
}

div := F(a, b N -> N, S) {
	[b == 0] <~ _, "Can't divide by zero"
	<~ a/b, _
}
