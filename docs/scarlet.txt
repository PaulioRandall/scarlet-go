
divideAndFmt := F(a, b, ^r, ^e) {
	WATCH e {
		[b = 0]: e := `Can't divide by zero`
		r, e := @FmtReal(a / b, `.##`)

		EXIT FUNC
	}
}

calc := F(argParser, ^e) {
	WATCH e {
		a, b := argParser(@Args())
		r, e := divideAndFmt(a, b)
		@Println("{a} / {b} = {r}")
	}
}

parseArgs := F(args, ^a, ^b, ^e) {
	WATCH e {
		[@Len(args) < 3]: e := `Need at least two number arguments`

		a, e := @ToReal(args(1))
		b, e := @ToReal(args(2))
	}
}

printValues := F(_, v, _) @Println(v)
@Foreach(@Args(), printValues)
e := calc(parseArgs)
@PanicIf(e)

list := LIST { 
	`abc`,
	3,
}

EXIT SCRIPT
EOF

// Future stuff

// Looping
LOOP i [exit] +1 {
	DONE
}

LOOP i, item, more <- list
	// Logic applied to each item
END

// Quick command line calls
$"ls -la"              // Execute a terminal process
output := $"ls -la"    // Return output as a list of strings
$"ls -la" IN `./other` // Execute within a specified folder

// Pairs
p := a: b       // Pair together `a` and `b` as KEY and VALUE
key, val := p   // Get the key and value
key, _ := p     // Get the key
_, val := p     // Get the value
map := {        // Combining lists and pairs produces a map
	`a`: `alpha`
	`b`: `beta`
	`c`: `charlie`
}
i, v := @Search(list, `b`) // Finds the specified pair searching on the key

// Spell receivers, the first parameter to the spell is the receiver
@Args().foreach(F(_, v, _) @Println(v))
"abc".println()
