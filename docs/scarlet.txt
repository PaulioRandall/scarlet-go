
divideAndFmt := F(a, b -> r, e) DO
	WATCH e
		[b = 0] DO
			e := `Can't divide by zero`
		END
		
		r := a / b
		r, e := @FmtReal(r, `.##`)
	END
END

calc := F(argParser -> e) DO
	WATCH e
		a, b := argParser(@Args())
		r, e := divideAndFmt(a, b)
		@Println("{a} / {b} = {r}")
	END
END

parseArgs := F(args -> a, b, e) DO
	WATCH e
		[@Len(args) < 3] DO
			e := `Need at least two number arguments`
		END

		a, e := @ToReal(args(1))
		b, e := @ToReal(args(2))
	END
END

printValues := F(_, v, _) @Println(v)
@Foreach(@Args(), printValues)
e := calc(parseArgs)
@PanicIf(e)

list := { 
	`abc`,
	3,
}

EOF

// Future stuff

// Looping
LOOP i [exit]
	// Repreated logic
END

LOOP i, item, more <- list
	// Logic applied to each item
END

// Quick command line calls
$"ls -la"              // Execute a terminal process
output := $"ls -la"    // Return output as a list of strings
$"ls -la" IN `./other` // Execute within a specified folder

// Pairs
p := a: b       // Pair together `a` and `b` as KEY and VALUE
key, val := p   // Get the key and value
key, _ := p     // Get the key
_, val := p     // Get the value
map := {        // Combining lists and pairs produces a map
	`a`: `alpha`
	`b`: `beta`
	`c`: `charlie`
}
i, v := @Search(list, `b`) // Finds the specified pair searching on the key

// Spell receivers, the first parameter to the spell is the receiver
@Args().foreach(F(_, v, _) @Println(v))
"abc".println()
