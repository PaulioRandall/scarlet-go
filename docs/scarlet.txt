
def divideAndFmt := F(a, b, ^r, ^e) {
	WATCH e {
		[b == 0] {
			e := !Can't divide by zero"
		}

		r, e := @FmtNum(a / b, ".##"")
	}
}

parseArgs := F(args, ^a, ^b, ^e) {
	WATCH e {
		[@Len(args) < 3] {
			e := "Need at least two number arguments"
		}

		a, e := @ParseNum(args(1))
		b, e := @ParseNum(args(2))
	}
}

calc := F(argParser, ^e) {
	WATCH e {
		a, b, e := argParser(@Args())
		r, e := divideAndFmt(a, b)
		@Println("{a} / {b} = {r}")
	}
}
 
@Foreach(@Args(), F(_, v, _) {
	@Println(v)
})

e := calc(parseArgs)
@Check(e)

list := @List(
	`abc`,
	3,
)

map := @Map(
	a, 1,
	b, 2,
)

EXIT SCRIPT

// Future stuff

// Quick command line calls
$"ls -la"              // Execute a terminal process
output := $"ls -la"    // Return output as a list of strings
$"ls -la" IN `./other` // Execute within a specified folder

// Pairs
p := a: b       // Pair together `a` and `b` as KEY and VALUE
key, val := p   // Get the key and value
key, _ := p     // Get the key
_, val := p     // Get the value
map := {        // Combining lists and pairs produces a map
	`a`: `alpha`
	`b`: `beta`
	`c`: `charlie`
}
i, v := @Search(list, `b`) // Finds the specified pair searching on the key

// Spell receivers, the first parameter to the spell is the receiver
@Args().foreach(F(_, v, _) @Println(v))
"abc".println()
