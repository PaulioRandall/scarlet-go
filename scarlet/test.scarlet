

factorial := F(n, ^r) LOOP i [i < n] {
	[i = 0] r := 1
	[i > 0] r := r * (i + 1)
}

answer := factorial(170)

EOF



[ADD list-based looping]

	[Formats]
		`LOOP` ID DELIM ID DELIM ID updates expression<list> full-block

	[Examples]
		LOOP index, value, hasMore <- list {}
		LOOP i, v, m <- f() {}

	[Steps]
		1. Add `<-` (UPDATES) symbol to scanner
		2. Add Iterator struct to statement pkg
		3. Add pattern to parser
		4. Add execution of Iterator to runtime

	[Tests]
		1. Scanner token: UPDATES `<-`
		2. Scanner statement: LOOP i, v, m <- list {}
		3. Scanner statement: LOOP i, v, m <- f() {}
		4. Parser statement: LOOP ID DELIM ID DELIM ID UPDATES ID BLOCK_OPEN ID ASSIGN NUMBER BLOCK_CLOSE
		5. Parser statement: LOOP ID DELIM ID DELIM ID UPDATES ID PAREN_OPEN PAREN_CLOSE BLOCK_OPEN ID ASSIGN NUMBER BLOCK_CLOSE
[-----------]


[REMOVE `Close` tokens]
	Remove the `Close` tokens from List/Guard/Block in the statement pkg
[-----------]	


[ENHANCE loops]

	[Current]
		LOOP i [i < n]

	[Allow]
		1. LOOP i := 0 [i < 5]
		2. F(n, ^r) LOOP n [n < 5]
[-----------]

[UPDATE context struct]
	Context getters and setters need to get their parents to handle a get or set
	and only use their variable arrays if the parents don't know about the specific identifier.
[-----------]

[ADD inbuilt functions]

	[Print function]
		Prints the args (variable length) to console
		@P(...)

	[Print line function]
		Prints the args (variable length) to console, and appends a linefeed
		@PL(...)

	[Examples]
		@P(`x: `, 1 + 2, "; ")
		@PL(list)
[-----------]

// TODO: NUMBER: float64 -> NUMBER: Float

// TODO: Prepend assignments with LET
LET x := 1

// MAYBE: Keywords be case-insensitive

// TODO: Access using expression
list[1 + 2] := `:)`

// TODO
s := "alpha = {list[0]}, beta = {list[1]}"

// MAYBE: = -> ==
// MAYBE: # -> !=

// MAYBE
increment := E(n) n + 1

// MAYBE
list[0] := _ // Removes the item from the list
x := list[>>] // Take last item
x := list[<<] // Take first item
list[>>] := 4 // Append to end
list[<<] := 0 // Append to front

// MAYBE
p := "key": "value"
k, v := p[K], p[V]

// MAYBE
@cd(`./scarlet-go`)
@cd(`..`)
@pushd(`./scarlet-go`)
$ `go build -o` filename `scarlet.go`
@popd()
build := E(file) $ `go build -o` file `scarlet.go`
