

factorial := F(n, ^r) LOOP i [i < n] {
	[i = 0] r := 1
	[i > 0] r := r * (i + 1)
}

answer := factorial(170)

EOF



[*****************************************************************************]
- Add list-based looping

- Formats
`LOOP` ID DELIM ID DELIM ID updates expression<list> full-block

- Examples
LOOP index, value, hasMore <- list {}
LOOP i, v, m <- f() {}

- Steps
1. Add `<-` (UPDATES) symbol to scanner
2. Add Iterator struct to statement pkg
3. Add pattern to parser
4. Add execution of Iterator to runtime

- Tests
1. Scanner token: UPDATES `<-`
2. Scanner statement: LOOP i, v, m <- list {}
3. Scanner statement: LOOP i, v, m <- f() {}
4. Parser statement: LOOP ID DELIM ID DELIM ID UPDATES ID BLOCK_OPEN ID ASSIGN NUMBER BLOCK_CLOSE
5. Parser statement: LOOP ID DELIM ID DELIM ID UPDATES ID PAREN_OPEN PAREN_CLOSE BLOCK_OPEN ID ASSIGN NUMBER BLOCK_CLOSE


[*****************************************************************************]
- Enhance loops

- Current
LOOP i [i < n]

- Allow
1. LOOP i := 0 [i < 5]
2. F(n, ^r) LOOP n [n < 5]


[*****************************************************************************]
- Update context struct

- Updates
1. When accessing a fixed value the Get function should search its parents fixed values if the current context doesn't have it, recursivily.
2. Spawn function no longer needs to copy the contents of fixed.
3. Get function should return nil if a variable doesn't exist.
4. When updating a variable value the Set function should first check the value is not fixed (check parents too), then check to see if it already exists as var (check parents too), and finally create a new local variable if there is no variable existing to update.


[*****************************************************************************]
- Add inbuilt functions

- Print function
Prints the args (variable length) to console
@P(...)

- Print line function
Prints the args (variable length) to console, and appends a linefeed
@PL(...)

- Examples
@P(`x: `, 1 + 2, "; ")
@PL(list)


[*****************************************************************************]
- Change numbers to Float
Change the type of number from float64 to Float, Go's std big float


[*****************************************************************************]
- Prepend assignments with LET

- Example
LET x := 1


[*****************************************************************************]
- Can Keywords be case-insensitive?


[*****************************************************************************]
- Access list items using numeric expressions

- Example
list[1 + 2] := `:)`


[*****************************************************************************]
- Template strings

- Example
s := "alpha = {list[0]}, beta = {list[1]}"


[*****************************************************************************]
- Change equality symbols

- Format
`=` to `==`
`#` to `!=`


[*****************************************************************************]
- Expression functions
Expression functions have a single expression as their body. The result of the expression is returned.

- Examples
increment := E(n) n + 1 


[*****************************************************************************]
- List access

- Access methods
list[0] := _ // Removes the item from the list
x := list[>>] // Take last item
x := list[<<] // Take first item
list[>>] := 4 // Append to end
list[<<] := 0 // Append to front


[*****************************************************************************]
- Key-value pairs

- Example
p := "key": "value"
k, v := p[K], p[V]


[*****************************************************************************]
- Simple directory navigation spells

- Spells
@cd(`./scarlet-go`)
@pushd(`./scarlet-go`)
@popd()


[*****************************************************************************]
- Quick shell commands

- Example 
$ `go build -o` filename `scarlet.go`
